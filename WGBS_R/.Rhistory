#in a previous step, we filtered out the genes that that zero counts in all samples or less than 10 reads across
#now with results() we  remove genes with an extreme count outlier and/or a low mean normalized count
#reference level = Control_CRISPRi
#e.g., log2(CRISPRi_targeting_ZNF384/Control CRISPRi)
CRISPRi_res <- results(CRISPRi_dds, contrast = c("CRISPRi_treatment", "CRISPRi_targeting_ZNF384", "Control_CRISPRi")) #variable name, numerator, denominator
CRISPRi_res_df <- as.data.frame(CRISPRi_res) #data.frame allows you to use CRISPRi results for other R packages
diff <- rownames_to_column(CRISPRi_res_df) #row names become a column
mcols(CRISPRi_res, use.names=TRUE) #carries metadata with information on the meaning of the columns
#dif_2 <- diff %>% dplyr::filter(str_detect(diff$rowname, pattern = "ENSG00000126746")) --> ENSEMBLE code for ZNF384
#filtering the results by their padj value
#if we consider a fraction of 5% false positives acceptable among differentially expressed genes, we can consider all genes with an adjusted p value below 5%=0.05 as significant; how many such genes are there?
#A separate adjusted p value is computed for each comparsion in a family of comparsions and each comparision has a unique adjusted P value
#P adj is the smallest family wise significance level at which a particular comparsion will be declared statistically significant as part of multiple comparison testing
CRISPRi_resSig <- CRISPRi_res[which(CRISPRi_res$padj < 0.05 ), ] #rowcounts 3962 (nrows)
CRISPRi_resSig1 <- CRISPRi_res[which(CRISPRi_res$pvalue < 0.05),] #rowcounts 8588 (nrows)
#CRISPRi_resSig2 <- CRISPRi_res[which(CRISPRi_res$log2FoldChange >=0), ] #rowcounts 13517 (nrows)
#CRISPRi_resSig3 <- CRISPRi_res[which(CRISPRi_res$log2FoldChange <0), ] #rowcounts 13517 (nrows)
#there are 8588 genes with a p value below 0.05 among the 34982 genes, for which the test succeeded in reporting a p value:
sum (CRISPRi_res$pvalue < 0.05, na.rm=TRUE)
#log2 fold change estimate; there are 3962 genes with a padj value below 0.05
sum (CRISPRi_res$padj < 0.05, na.rm=TRUE)
#sorted by the log2 fold change estimate to get the significant genes with the strongest down-regulation
head (CRISPRi_resSig[ order( CRISPRi_resSig$log2FoldChange ), ] )
#and with the strongest upregulation
tail (CRISPRi_resSig[ order( CRISPRi_resSig$log2FoldChange ), ] )
#using normalization factors (size factors) to account for differences in RNA library depth
CRISPRi_dds <- estimateSizeFactors(CRISPRi_dds)
#visualize DESeq2's dispersion estimates
#e.g., a dispersion value of 0.01 means that the gene's expression tends to differ by typically 10% between samples of the same treatment group
plotDispEsts ( CRISPRi_dds, ylim = c(1e-6, 1e2) )
#generating a transformed version of count data from samples using vsd or rld, which is useful for downstream analyses -- e.g., for visualization or clustering (PCA, pheatmap)
#varianceStabilizingTransformation = VST
#vst tansformation is less sensitive to outliers, best for medium to large datasets
#This function transforms the count data to the log2 scale in a way which minimizes differences between samples for rows with small counts, and which normalizes with respect to library size
#setting blind to FALSE means the transformation will NOT be blind to the sample information provided by the design formula
CRISPRi_vsd <- vst(CRISPRi_dds, blind = FALSE)
#head(assay(CRISPRi_vsd), 3) --> the assay function extracts matrix of normalized values
#works well on small datasets and outperforms vst when there is a wide range of sequencing depth (not necessarily us but the sample number is --> will use this)
#regularizedlogarithm = rlog
#rlog also produces transformed data on the log2 scale like the vst function
#rlog-transformed data are approximately homoskedastic, so the variance does not depenend on the mean
CRISPRi_rld <- rlog(CRISPRi_dds, blind = FALSE)
#calculate the Euclidean distance between samples, use VST to confirm ~equal contribution from all genes
#Euclidean distance is the distance between two points in a two-dimensional space
#Heatmap shows the Euclidean distance between samples as calculated from the VST of the count data
#A heatmap of this distance matrix gives us an overview of similarities and dissimilarities between samples
#pheatmap is a function of the pheatmap package
dev.off()
sampleDists <- dist(t(assay(CRISPRi_vsd))) #extracts the rlog matrix from the object
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- NULL
colnames(sampleDistMatrix) <- paste( CRISPRi_samples )
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDists,
clustering_distance_cols = sampleDists)
#creating a PCA plot of all replicates = how well do our replicates cluster together? does our experimental condition represent the major source of variation in our data?
#PCA plots are used to evalaute the relations among samples
#In other words, PCA summarizes variance in our dataset, or how our samples vary from each other
#PC1 vs PC2: PC1 is x-axis and describes the direction which separates the data points the most (i.e., largest spread in the data); PC2 represents the second most amount of varation in the data
#The amount of the total variance which is contained in the direction is printed in the axis label
#plotPCA is a function of the DESeq2 package
#88% of the differences among our samples can be grouped together in a way that defines that axis of separation and that other 10% compromises another 'grouping' of separations that fall into the other category
#using vst transformation of the normalized counts as it moderates the variance across the mean, improving the clustering
#by default the plotPCA() function only returns the values for PC1 and PC2
plotPCA(CRISPRi_vsd, intgroup = "CRISPRi_treatment",)
#plotting histograms of log2fold change and padj
#customize the PCA plot using the ggplot function
CRISPRi_resSig_df <- as.data.frame(CRISPRi_resSig)
ggplot(CRISPRi_resSig_df, aes(x=log2FoldChange)) +
geom_histogram(binwidth=.1, color="black", fill="gray")
#plotting the log2foldchange distribution for my data set on the same graph for signficant data points
SigGenes_log2foldchange_distribution <- ggplot(NULL, aes(x=log2FoldChange), fill = "white") +
xlim(c(-15,15))+
geom_histogram(data = CRISPRi_resSig_df, aes(x = log2FoldChange, color = "Control vs CRISPRi", fill = "Control vs CRISPRi"), binwidth=1, alpha=0.5) +
theme_classic()+
scale_colour_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
scale_fill_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
labs(title ="Significant Log2FoldChange", x = "Log2FoldChange", y = "Number of Genes")
ggsave(filename = "SigGenes_log2foldchange_distribution.eps",
plot = print(SigGenes_log2foldchange_distribution),
device = cairo_ps)
#plotting the log2foldchange distribution for my data set (+/-)1.5
#filter for log2foldchange outside of (+/-)1.5
CRISPRi_resSig_df_log <- CRISPRi_resSig_df %>%
rownames_to_column("gene") %>%
filter(log2FoldChange < -1.5 | log2FoldChange > 1.5) %>%
column_to_rownames("gene")
write.csv(CRISPRi_resSig_df_log, file = "CRISPRiControlvsKnockdown_sig_log_results.csv")
ggplot(NULL, aes(x=log2FoldChange), fill = "white") +
xlim(c(-15,15))+
geom_histogram(data = CRISPRi_resSig_df_log, aes(x = log2FoldChange, color = "Control vs CRISPRi", fill = "Control vs CRISPRi"), binwidth=.5, alpha=0.5) +
theme_classic()+
scale_colour_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
scale_fill_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
labs(title ="Significant Log2FoldChange", x = "Log2FoldChange", y = "Number of Genes")
#filter for log2foldchange outside of +1.5
CRISPRi_resSig_df_log_upreg <- CRISPRi_resSig_df %>%
rownames_to_column("gene") %>%
filter(log2FoldChange > 1.5) %>%
column_to_rownames("gene")
write.csv(CRISPRi_resSig_df_log_upreg, file = "CRISPRiControlvsKnockdown_sig_log_upregulated_results.csv")
ggplot(NULL, aes(x=log2FoldChange), fill = "white") +
xlim(c(-15,15))+
geom_histogram(data = CRISPRi_resSig_df_log_upreg, aes(x = log2FoldChange, color = "Control vs CRISPRi", fill = "Control vs CRISPRi"), binwidth=.5, alpha=0.5) +
theme_classic()+
scale_colour_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
scale_fill_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
labs(title ="Significant Log2FoldChange", x = "Log2FoldChange", y = "Number of Genes")
#filter for log2foldchange outside of -1.5
CRISPRi_resSig_df_log_downreg <- CRISPRi_resSig_df %>%
rownames_to_column("gene") %>%
filter(log2FoldChange < -1.5) %>%
column_to_rownames("gene")
write.csv(CRISPRi_resSig_df_log_downreg, file = "CRISPRiControlvsKnockdown_sig_log_downregulated_results.csv")
ggplot(NULL, aes(x=log2FoldChange), fill = "white") +
xlim(c(-15,15))+
geom_histogram(data = CRISPRi_resSig_df_log_downreg, aes(x = log2FoldChange, color = "Control vs CRISPRi", fill = "Control vs CRISPRi"), binwidth=.5, alpha=0.5) +
theme_classic()+
scale_colour_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
scale_fill_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
labs(title ="Significant Log2FoldChange", x = "Log2FoldChange", y = "Number of Genes")
#plotting the padj distribution for my data set on the same graph
ggplot(NULL, aes(x=padj), fill = "white") +
geom_histogram(data = CRISPRi_resSig_df, aes(x = padj, color = "Control vs CRISPRi", fill = "Control vs CRISPRi"), binwidth=0.005, alpha=0.5) +
theme_classic()+
scale_colour_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
scale_fill_brewer("",
breaks = c("Control vs CRISPRi"),
palette = "Paired") +
labs(title ="Significant Padj", x = "adjusted P-value", y = "Number of Genes")
#MA-plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested
#Each dot represents a gene; x-axis is the average expression over all samples; y-axis is the log2 fold change between treatment and control
#Genes with an adj pvalue below 0.05 are shown in red
#This plot demonstrates that genes with a low average normalized count contain sufficient information to yield a significant call
plotMA(CRISPRi_res, alpha = 0.05, ylim = c(-10, 10))
#logfold change shrinkage
CRISPRi_resLFC<- lfcShrink(CRISPRi_dds, contrast = c("CRISPRi_treatment", "CRISPRi_targeting_ZNF384", "Control_CRISPRi"), library = "normal")
#create MA-plot from LFC results
CRISPRi_resLFC_MAplot <- plotMA(CRISPRi_resLFC, ylim = c(-10, 10), main = "Control CRISPRi vs CRISPRi targeting ZNF384", alpha = 0.05)
#select the 250 genes with the highest variance across samples
#work with rlog transformed counts to create most variable gene heatmap
topVarGenes <- head( order( rowVars( assay(CRISPRi_rld) ), decreasing=TRUE ), 250 )
mat <- assay(CRISPRi_rld)[ topVarGenes, ]
anno <- as.data.frame(colData(CRISPRi_rld))
pheatmap(mat,
scale = "row",
annotation_col = anno,
show_rownames = FALSE)
#export these results in a CSV file, which you can load with a spreadsheet program such as Excel
write.csv(mat, file = "topVarGenes.csv")
#select the 100 genes with the highest mean across samples
topMeanGenes <- head( order(rowMeans(assay(CRISPRi_rld)), decreasing=TRUE ), 100)
mat1 <- assay(CRISPRi_rld)[ topMeanGenes, ]
anno1 <- as.data.frame(colData(CRISPRi_rld))
pheatmap(assay(CRISPRi_rld)[topMeanGenes, ],
scale = "row",
annotation_col = anno,
show_rownames = FALSE)
#export these results in a CSV file, which you can load with a spreadsheet program such as Excel
write.csv(mat1, file = "topMeanGenes.csv")
ens.str1 <- substr(rownames(mat), 1, 15)
mat$symbol <- mapIds(org.Hs.eg.db,
keys=ens.str1,
column="SYMBOL",
keytype="ENSEMBL",
multiVals="first")
mat$entrez <- mapIds(org.Hs.eg.db,
keys=ens.str1,
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
View(mat1)
View(mat1)
View(mat)
library("AnnotationDbi")
library("org.Hs.eg.db")
ens.str1 <- substr(rownames(mat), 1, 15)
mat$symbol <- mapIds(org.Hs.eg.db,
keys=ens.str1,
column="SYMBOL",
keytype="ENSEMBL",
multiVals="first")
mat$entrez <- mapIds(org.Hs.eg.db,
keys=ens.str1,
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
View(mat1)
ens.str2 <- substr(rownames(mat1), 1, 15)
mat1$symbol <- mapIds(org.Hs.eg.db,
keys=ens.str2,
column="SYMBOL",
keytype="ENSEMBL",
multiVals="first")
mat1$entrez <- mapIds(org.Hs.eg.db,
keys=ens.str2,
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
View(mat1)
View(mat1)
topVarGenes <- head( order( rowVars( assay(CRISPRi_rld) ), decreasing=TRUE ), 250 )
mat <- assay(CRISPRi_rld)[ topVarGenes, ]
anno <- as.data.frame(colData(CRISPRi_rld))
pheatmap(mat,
scale = "row",
annotation_col = anno,
show_rownames = FALSE)
#export these results in a CSV file, which you can load with a spreadsheet program such as Excel
write.csv(mat, file = "topVarGenes.csv")
topMeanGenes <- head( order(rowMeans(assay(CRISPRi_rld)), decreasing=TRUE ), 100)
mat1 <- assay(CRISPRi_rld)[ topMeanGenes, ]
anno1 <- as.data.frame(colData(CRISPRi_rld))
pheatmap(assay(CRISPRi_rld)[topMeanGenes, ],
scale = "row",
annotation_col = anno,
show_rownames = FALSE)
#export these results in a CSV file, which you can load with a spreadsheet program such as Excel
write.csv(mat1, file = "topMeanGenes.csv")
CRISPRi_genes_padj <- as.data.frame(read.csv("ControlvsCRISPRi_results.csv"))
CRISPRi_genes_padj_entrez <- as.character(CRISPRi_genes_padj$entrez)
CRISPRi_GO <- enrichGO(CRISPRi_genes_padj_entrez,
ont = "BP",
OrgDb="org.Hs.eg.db",
pvalueCutoff = 0.05,
keyType = "ENTREZID",
pAdjustMethod = "BH")
dotplot(CRISPRi_GO,
title = "Padj < 0.05 Ontology",
showCategory = 15)
CRISPRi_GO_CC <- enrichGO(CRISPRi_genes_padj_entrez,
ont = "CC",
OrgDb="org.Hs.eg.db",
pvalueCutoff = 0.05,
keyType = "ENTREZID",
pAdjustMethod = "BH")
dotplot(CRISPRi_GO_CC,
title = "Padj < 0.05 CC Ontology",
showCategory = 15)
##Dose measures semantic similarities among DO terms and gene products. Enrichment analyses including hypergeometric model and gene set enrichment analysis are also implemented for discovering disease associations##
library(DOSE)
##clusterProfilers implements methtods to analyze and visualize functional profiles (GO and KEGG) of gene and gene clusters##
library(clusterProfiler)
##A system for declaratively creating graphics; found in tidyverse##
library(ggplot2)
##collection of R packages for data science##
library(tidyverse)
##reads rectangular data (like csv, tsv, and fwf; found in tidyverse##
library(readr)
##annotating ChIP-seq data analysis##
library(ChIPseeker)
##assesses association between genomic region sets and other genomic features##
library(regioneR)
##annotation database for hg19 generated by UCSC##
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(tidyverse)
beta_cs <- read_tsv("CT_B_cellspecific.txt", col_names = FALSE)
setwd("~/Desktop/PhD_Research/WGBS_MethPipe_Islet_Cells/WGBS_R")
##Load in bed files, which have been converted to .txt files##
#use col_names = FALSE to tell read_tsv() to not treat the first row as headings, and instead label them sequentially from X1 to Xn
beta_cs <- read_tsv("CT_B_cellspecific.txt", col_names = FALSE)
#add column names
colnames(beta_cs)<-c("Chr","Start","End","Length")
beta_cs <- beta_cs %>%
dplyr::select("Chr","Start","End") %>%
mutate("ID"=row_number(), "Strand"=".", "OtherCol"="1")
View(beta_cs)
alpha_cs <- read_tsv("CT_A_cellspecific.txt", col_names = F)
colnames(alpha_cs)<-c("Chr","Start","End","Length")
alpha_cs <- alpha_cs %>%
dplyr::select("Chr","Start","End") %>%
mutate("ID"=row_number(), "Strand"=".", "OtherCol"="1")
View(beta_cs)
# Convert them to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
library(ChIPseeker
# Convert them to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
##annotating ChIP-seq data analysis##
library(ChIPseeker)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker")
##annotating ChIP-seq data analysis##
library(ChIPseeker)
# Converts UCSB BED format to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPpeakAnno")
library(ChIPpeakAnno)
# Converts UCSB BED format to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
View(beta_cs_granges)
if (!require("BiocManager"))
install.packages("BiocManager")
BiocManager::install("GenomicRanges")
##used for creating GRanges objects, which represent a collection of genomic ranges that each have a single start and end location on the genome##
library(GenomicRanges)
# Converts UCSB BED format to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
# Converts UCSB BED format to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
alpha_cs_granges <- toGRanges(as.data.frame(alpha_cs))
View(alpha_cs)
# Converts UCSB BED format to GRanges
beta_cs_granges_2 <- toGRanges(as.data.frame(beta_cs))
rm(beta_cs_granges)
# Converts UCSB BED format to GRanges
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
rm(beta_cs_granges_2)
View(beta_cs_granges)
View(alpha_cs_granges)
beta_cs_granges
seqnames(beta_cs_granges)
ranges(beta_cs_granges)
strand(beta_cs_granges)
granges(beta_cs_granges)
#prints alpha_cs_granges object
alpha_cs_granges
#prints beta_cs_granges object
beta_cs_granges
seqinfo(beta_cs_granges)
seqinfobeta_cs_granges <- seqinfo(beta_cs_ranges)
seqinfobeta_cs_granges <- seqinfo(beta_cs_granges)
View(seqinfobeta_cs_granges)
seqinfobeta_cs_granges <- seqinfo(as.data.frame(beta_cs_granges))
seqinfobeta_cs_granges <- seqinfo(beta_cs_granges)
View(seqinfobeta_cs_granges)
View(seqinfobeta_cs_granges)
seqinfobeta_cs_granges
#
seqinfo_beta_cs_granges <- seqinfo(beta_cs_granges)
rm(seqinfobeta_cs_granges)
#GRanges operates within a universe of sequences (chromosomes/contigs) and their lengths
#180 beta-cell specific HMRs from an unspecified genome; no seqlengths
unspecified_beta_cs_granges <- seqinfo(beta_cs_granges)
rm(seqinfo_beta_cs_granges)
genome(unspecified_beta_cs_granges) <- "hg19"
unspecified_beta_cs_granges
unspecified_beta_cs_granges
unspecified_beta_cs_granges
#prints beta_cs_granges object
#'*' value indicates 'unknown strand' or 'unstranded'; strands can also be + or -
beta_cs_granges
genome(unspecified_beta_cs_granges) <- "NA"
unspecified_beta_cs_granges
#GRanges operates within a universe of sequences (chromosomes/contigs) and their lengths
#180 beta-cell specific HMRs from an unspecified genome; no seqlengths
unspecified_beta_cs_granges <- seqinfo(beta_cs_granges)
unspecified_beta_cs_granges
#prints alpha_cs_granges object
alpha_cs_granges
unspecificied_alpha_cs_granges <- seqinfo(alpha_cs_granges)
unspecificied_alpha_cs_granges
gaps(unspecified_beta_cs_granges)
gaps(beta_cs_granges)
beta_cs_granges
gaps(beta_cs_granges)
##assesses association between genomic region sets and other genomic features##
library(regioneR)
remove.packages(ChIPpeakAnno)
seqinfo(beta_cs)
##Dose measures semantic similarities among DO terms and gene products. Enrichment analyses including hypergeometric model and gene set enrichment analysis are also implemented for discovering disease associations##
library(DOSE)
##clusterProfilers implements methtods to analyze and visualize functional profiles (GO and KEGG) of gene and gene clusters##
library(clusterProfiler)
##A system for declaratively creating graphics; found in tidyverse##
library(ggplot2)
##collection of R packages for data science##
library(tidyverse)
##reads rectangular data (like csv, tsv, and fwf; found in tidyverse##
library(readr)
##annotating ChIP-seq data analysis##
library(ChIPseeker)
##assesses association between genomic region sets and other genomic features##
library(regioneR)
##annotation database/data/ packages for hg38 generated by UCSC##
##consists of a set of annotations that describes the genomic locations of the known genes, transcripts, exons, and CDS, for humans##
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
##a pre-made TxDb objects wrapped into the hg38 annotation data packages##
txtdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
##used for creating GRanges objects, which represent a collection of genomic ranges that each have a single start and end location on the genome##
library(GenomicRanges)
##Set working directory##
setwd("~/Desktop/PhD_Research/WGBS_MethPipe_Islet_Cells/WGBS_R")
##Load in bed files, which have been converted to .txt files##
#use col_names = FALSE to tell read_tsv() to not treat the first row as headings, and instead label them sequentially from X1 to Xn
beta_cs <- read_tsv("CT_B_cellspecific.txt", col_names = FALSE)
#add column names
colnames(beta_cs)<-c("Chr","Start","End","Length")
#load tidyverse again to call select function from dplyer
#use mutate() to add new variables
beta_cs <- beta_cs %>%
dplyr::select("Chr","Start","End") %>%
mutate("ID"=row_number(), "Strand"=".", "OtherCol"="1")
View(beta_cs)
alpha_cs <- read_tsv("CT_A_cellspecific.txt", col_names = F)
View(alpha_cs)
colnames(alpha_cs)<-c("Chr","Start","End","Length")
alpha_cs <- alpha_cs %>%
dplyr::select("Chr","Start","End") %>%
mutate("ID"=row_number(), "Strand"=".", "OtherCol"="1")
View(alpha_cs_granges)
View(alpha_cs_granges)
View(alpha_cs)
beta_cs_granges <- toGRanges(as.data.frame(beta_cs))
alpha_cs_granges <- toGRanges(as.data.frame(alpha_cs))
seqinfo(beta_cs_granges)
summary(beta_cs_granges)
seqinfo(beta_cs)
View(beta_cs)
View(alpha_cs_granges)
seqnames(alpha_cs_granges)
seqlevels(alpha_cs_granges)
genome(alpha_cs_granges)
View(unspecificied_alpha_cs_granges)
View(unspecified_beta_cs_granges)
summary(beta_cs_granges)
genome(beta_cs_granges)
length(beta_cs_granges)
seqnames(beta_cs_granges)
seqlevels(beta_cs_granges)
View(beta_cs_granges)
isCircular(beta_cs_granges)
View(alpha_cs_granges)
#prints beta_cs_granges object
#'*' value indicates 'unknown strand' or 'unstranded'; strands can also be + or -
beta_cs_granges
##Having fun with GRanges functions##
#extracts seqnames
seqnames(beta_cs_granges)
seqlevels(beta_cs_granges)
remove(unspecificied_alpha_cs_granges)
remove(unspecified_beta_cs_granges)
#GRanges operates within a universe of sequences (chromosomes/contigs) and their lengths
#180 sequences from an unspecified genome; no seqlengths
seqinfo_beta_cs_granges <- seqinfo(beta_cs_granges)
View(seqinfo_beta_cs_granges)
View(seqinfo_beta_cs_granges)
beta_cs_granges
#extracts genomic ranges of HMRs
ranges(beta_cs_granges)
#extracts length of GRanges object (i.e., 14522 HMRs)
strand(beta_cs_granges)
#extracts genomic ranges without corresponding dummy variables
granges(beta_cs_granges)
sort(beta_cs_granges)
seqlevel(beta_cs_granges)
seqlevels(beta_cs_granges)
#prints beta_cs_granges object
#'*' value indicates 'unknown strand' or 'unstranded'; strands can also be + or -
beta_cs_granges
genome(beta_cs_granges) <- "hg38"
beta_cs_granges
seqinfo(beta_cs_granges)
#gaps() returns the stretches of the genome not covered by the GRanges
gaps(beta_cs_granges)
##Having fun with GRanges functions##
#extracts seqnames or names of the sequences in beta_cs_granges; these names must be non-empty and unique
seqnames(beta_cs_granges)
seqlevels(beta_cs_granges)
genome(alpha_cs_granges) <- "hg38"
seqinfo(alpha_cs_granges)
seqlevels(alpha_cs_granges)
seqnames(alpha_cs_granges)
gaps(alpha_cs_granges)
seqlevels(alpha_cs_granges)
seqinfo(alpha_cs_granges)
seqlevels(beta_cs_granges)
seqinfo(beta_cs_granges)
seqlevels(beta_cs_granges)
seqnames(beta_gs_ranges)
seqnames(beta_cs_granges)
remove(seqinfo_beta_cs_granges)
seqinfo(beta_cs_granges)
beta_cs_granges
seqlevelsIbeta_cs_granges)
seqlevels(beta_cs_granges)
seqnames(beta_cs_granges)
View(alpha_cs_granges)
View(alpha_cs)
R -version
R --version
##Set working directory##
setwd("~/Desktop/PhD_Research/WGBS_MethPipe_Islet_Cells/WGBS_R")
pwd
##Load in bed files, which have been converted to .txt files##
#use col_names = FALSE to tell read_tsv() to not treat the first row as headings, and instead label them sequentially from X1 to Xn
beta_cs <- read_tsv("CT_B_cellspecific.txt", col_names = FALSE)
##Set working directory##
setwd("~/Desktop/PhD_Research/WGBS_MethPipe_Islet_Cells/WGBS_R")
getwd()
